// ----------------------------------------------------------------------
// File generated by NStack Translations Generator v5.0.
//
// Copyright (c) 2019 Nodes ApS
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ----------------------------------------------------------------------

import Foundation
import NStackSDK

#if canImport(NLocalizationManager)
import NLocalizationManager
#endif

#if canImport(LocalizationManager)
import LocalizationManager
#endif

public var skl: SKLocalizations {
    return SKLocalizations()
}

public var skt: SKLocalizations { skl }

public final class SKLocalizations: LocalizableModel {
    public var defaultSection = DefaultSection()

    enum CodingKeys: String, CodingKey {
        case defaultSection = "default"
    }

    public override init() { super.init() }

    public required init(from decoder: Decoder) throws {
        super.init()
        let container = try decoder.container(keyedBy: CodingKeys.self)
        defaultSection = try container.decodeIfPresent(DefaultSection.self, forKey: .defaultSection) ?? defaultSection
    }

    public override subscript(key: String) -> LocalizableSection? {
        switch key {
        case CodingKeys.defaultSection.stringValue: return defaultSection
        default: return nil
        }
    }

    public final class DefaultSection: LocalizableSection {
        public var loginThanks = ""
        public var profileFirstName = ""
        public var loginPlease = ""
        public var profileLastName = ""

        enum CodingKeys: String, CodingKey {
            case loginThanks
            case profileFirstName
            case loginPlease
            case profileLastName
        }

        public override init() {
            super.init()
            loginThanks = "\(classNameLowerCased()).loginThanks"
            profileFirstName = "\(classNameLowerCased()).profileFirstName"
            loginPlease = "\(classNameLowerCased()).loginPlease"
            profileLastName = "\(classNameLowerCased()).profileLastName"
        }

        public required init(from decoder: Decoder) throws {
            super.init()
            let container = try decoder.container(keyedBy: CodingKeys.self)
            loginThanks = try container.decodeIfPresent(String.self, forKey: .loginThanks) ?? "__loginThanks"
            profileFirstName = try container.decodeIfPresent(String.self, forKey: .profileFirstName) ?? "__profileFirstName"
            loginPlease = try container.decodeIfPresent(String.self, forKey: .loginPlease) ?? "__loginPlease"
            profileLastName = try container.decodeIfPresent(String.self, forKey: .profileLastName) ?? "__profileLastName"
        }

        public override subscript(key: String) -> String? {
            return ""
        }
    }
}

