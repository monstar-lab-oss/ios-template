// ----------------------------------------------------------------------
// File generated by NStack Translations Generator v5.0.
//
// Copyright (c) 2019 Nodes ApS
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ----------------------------------------------------------------------

import Foundation
import NStackSDK

#if canImport(NLocalizationManager)
import NLocalizationManager
#endif

#if canImport(LocalizationManager)
import LocalizationManager
#endif

public var lo: Localizations {
    guard let manager = NStack.sharedInstance.localizationManager else {
        return Localizations()
    }
    return try! manager.localization()
}

public var tr: Localizations { lo }

public final class Localizations: LocalizableModel {
    public var defaultSection = DefaultSection()

    enum CodingKeys: String, CodingKey {
        case defaultSection = "default"
    }

    public override init() { super.init() }

    public required init(from decoder: Decoder) throws {
        super.init()
        let container = try decoder.container(keyedBy: CodingKeys.self)
        defaultSection = try container.decodeIfPresent(DefaultSection.self, forKey: .defaultSection) ?? defaultSection
    }

    public override subscript(key: String) -> LocalizableSection? {
        switch key {
        case CodingKeys.defaultSection.stringValue: return defaultSection
        default: return nil
        }
    }

    public final class DefaultSection: LocalizableSection {
        public var profileLastName = ""
        public var loginPlease = ""
        public var loginThanks = ""
        public var profileFirstName = ""

        enum CodingKeys: String, CodingKey {
            case profileLastName
            case loginPlease
            case loginThanks
            case profileFirstName
        }

        public override init() { super.init() }

        public required init(from decoder: Decoder) throws {
            super.init()
            let container = try decoder.container(keyedBy: CodingKeys.self)
            profileLastName = try container.decodeIfPresent(String.self, forKey: .profileLastName) ?? "__profileLastName"
            loginPlease = try container.decodeIfPresent(String.self, forKey: .loginPlease) ?? "__loginPlease"
            loginThanks = try container.decodeIfPresent(String.self, forKey: .loginThanks) ?? "__loginThanks"
            profileFirstName = try container.decodeIfPresent(String.self, forKey: .profileFirstName) ?? "__profileFirstName"
        }

        public override subscript(key: String) -> String? {
            switch key {
            case CodingKeys.profileLastName.stringValue: return profileLastName
            case CodingKeys.loginPlease.stringValue: return loginPlease
            case CodingKeys.loginThanks.stringValue: return loginThanks
            case CodingKeys.profileFirstName.stringValue: return profileFirstName
            default: return nil
            }
        }
    }
}

